import Giscus from "@giscus/react";
import { Alert, Collapse, Rate, Button, Result, Typography } from "antd";
import { SnippetsTwoTone, QuestionCircleTwoTone } from "@ant-design/icons";
import { red, green } from "@ant-design/colors";

# 원시값과 참조값

## 개념 정리

자바스크립트의 모든 자료형은 그 동작 방식의 차이에 따라 원시값 혹은 참조값 두 가지 카테고리로 나눌 수 있습니다.

### 원시값 (Primitive)

- String
- Boolean
- Number
- Null
- Undefined
- Symbol

### 참조값 (Reference)

- Object

> Object란, 함수, 배열 등이 모두 포함됩니다.

이 자료형에 따른 동작 방식의 차이를 잘 이해하는 것은 여러분이 여러분의 코드를 이해하는데 있어 매우 중요한 역할을 할 것입니다. 원시값은 단순하기에 이해하기 어렵지 않겠지만, 참조값의 경우 실제 상황에서 많은 경험을 쌓아야 개념 숙지가 이루어질 수 있습니다. 과제를 작업하면서 깊게 생각해보세요.

<br/>
<br/>
## 원시값

원시값의 작동 원리는 매우 간단합니다. 아마 여러분도 이미 잘 알고 계실 겁니다.

##### 예시 1.

```js showLineNumbers {5} copy
// 문자열은 원시값에 해당하는 자료형입니다.
const person1 = "wan";
const person2 = "wan";

const result = person1 === person2;

console.log(result);
```

원시값의 경우에는 단순하게 생각하시면 됩니다.

<br />
<Alert
  showIcon
  message="값의 '모양'이 같다면, 서로 같은 값입니다. 값의 '모양'이 다르다면, 서로 다른 값입니다."
  type="info"
/>

위의 예제에서 우리는 두 가지 변수를 만들었습니다. `person1`과 `person2` 모두 `"wan"`이라는 문자열을 담고 있습니다. 그렇기에, 두 가지 변수를 비교한다면 같다고 판별됩니다.

<br />
<br />

너무 단순한 예시 코드를 보았으니, 조금 다채로운 내용이 담긴 코드를 살펴볼까요?

##### 예시 2.

```js showLineNumbers {2, 4} copy
let a = 10;
const b = a;

a = 30;

console.log(b);
```

위 예제에서 우리는 `b`라는 변수를 선언하고, `a`와 동일한 값을 할당해주었습니다. 그리고 `a` 변수의 값을 변경하였습니다.

<br />

<Collapse>
  <Collapse.Panel header="과연 `b`의 값은 무엇일까요? 30초 이상 생각해보시고 설명을 열어서 읽어보세요.">
    <p>
      우리가 변수를 만드는 행위를 포스트잇에 정보를 적는 행위에 비유한다고 생각해보세요. 다만, 아래와 같은 두 가지 조건이 있습니다.

      * 하나의 포스트잇에는 하나의 원시값만 적을 수 있습니다.
      * 한번 사용한 포스트잇은 재사용하지 않습니다.

      이런 조건을 감안하고 우리에게 주어진 예제 코드를 다시 보자면, 아래와 같다고 할 수 있습니다.

      1. 1번째 줄에서 `a`라는 포스트잇에 10이라는 숫자를 적었습니다.
      2. 2번째 줄에서 `b`라는 포스트잇에 `a` 포스트잇에 적혀있는 내용을 적습니다. 10이라는 숫자를 적습니다.
      3. 4번째 줄에서 우리는 새로운 포스트잇에 30을 적고, 이 새로운 포스트잇을 `a`라는 이름으로 사용합니다. (기존 `a` 포스트잇은 버려집니다.)
      4. 6번째 출에서 `b` 포스트잇에 적힌 글씨를 확인합니다. 결과는 10입니다.
    </p>
  </Collapse.Panel>
</Collapse>

<br/>
<br/>
## 참조값

참조값 형태로 작동하는 자료형은 객체, 단 하나 뿐입니다. 물론, 자바스크립트에서는 배열과 함수도 객체에 포함된다는 사실을 잊지 마세요!

<br/>
<br/>

여러분의 이목을 집중시키기 위해, **우선 간단하지만 충격적인 예제부터 보여드리겠습니다.**

##### 예시 3.

```js showLineNumbers copy
const list1 = [ 1, 2, 3 ];
const list2 = [ 1, 2, 3 ];

const result = list1 === list2;

console.log(result); // ?
```

<br/>

<Collapse>
  <Collapse.Panel header="콘솔에 출력되는 결과는 무엇일까요? 30초 이상 생각해보시고 설명을 열어서 읽어보세요.">
    <p>
      결론부터 말씀드리자면, 위 콘솔 출력 결과는 `false`입니다. 이 부분에 대한 작동 원리는 비유적으로 설명드리는 편이 나을 것 같습니다.

      우리는 기존과 같이 포스트잇을 사용합니다. 이번에도 또한 몇 가지 규칙이 존재합니다.

      * 하나의 포스트잇에는 하나의 정보만 적을 수 있고, 재활용하지 않습니다.
      * 참조값 형태의 자료들은 그 부피가 방대하여 포스트잇에 적을 수 없습니다.
      * 참조값 형태의 실제 자료들은 별도의 자료 저장소인 서랍장에 보관해야 하며, 하나의 서랍장에는 하나의 자료만 보관할 수 있습니다.
      * 참조값(객체)을 담는 포스트잇에는 그 자료의 **서랍장 위치**를 적어 놓습니다.

      ```js showLineNumbers copy
      const list1 = [ 1, 2, 3 ];
      const list2 = [ 1, 2, 3 ];

      const result = list1 === list2;

      console.log(result);
      ```

      위의 예시 코드에서는 다음과 같은 방식으로 동작합니다.

      1. 1번째 줄의 코드는 **배열을 생성하는 코드**입니다.
      2. 1번째 줄의 `[1, 2, 3]`이라는 자료는 참조값이기에 포스트잇에 적을 수 없습니다. 그래서 우리는 **서랍장 첫 번째 칸**에 보관합니다.
      3. 1번째 줄의 `list1`이라는 이름의 포스트잇에는 **서랍장 첫 번째 칸**이라고 해당 자료가 보관된 위치 정보를 적습니다.
      4. 2번째 줄의 코드는 1번째 줄의 배열과는 무관하게, **또 다른 새로운 배열을 생성하는 코드**입니다.
      5. 2번째 줄의 `[1, 2, 3]`이라는 자료는 포스트잇에 적을 수 없기 때문에, **서랍장 두 번째 칸**에 보관합니다.
      6. 2번째 줄의 `list2`이라는 이름의 포스트잇에는 **서랍장 두 번째 칸**이라고 해당 자료가 보관된 위치 정보를 적습니다.
      7. 4번째 줄에서 `result`라는 이름의 포스트잇에 `list1`과 `list2` 포스트잇에 적힌 내용이 같은지를 판별한 결과를 연산하여 담으려고 시도합니다.
      8. `list1`에 담긴 정보는 **서랍장 첫 번째 칸**이고, `list2`에 담긴 정보는 **서랍장 두 번째 칸**입니다. 같지 않으므로 `list1 === list2{:js}`의 연산 결과는 `false{:js}`입니다.
      9. `false`는 원시값이기에, 4번째 줄의 `result`라는 이름의 포스트잇에는 `false`라는 원시값을 직접 적어 놓을 수 있습니다.
      10. 6번째 줄에서 `result`라는 포스트잇의 정보를 확인하여 콘솔에 출력하면, 해당 포스트잇에 적어 놓은 `false`라는 정보가 출력됩니다.

      참조값의 동작 방식이 한층 더 이해되었을까요? 실제 상황은 이보다 더 복잡할 수 있지만, 근본적으로 이런 방식으로 동작함을 잊지 않고 살펴보신다면 결코 이해되지 않는 부분은 없을거라고 장담합니다.
    </p>
  </Collapse.Panel>
</Collapse>

자바스크립트의 모든 객체는 위와 같은 방식으로 작동하며, 여러분도 위 과정을 반드시 이해하셔야 합니다.

<br />
<br />

또 다른 예시 코드를 한번 살펴볼까요?

##### 예시 4.

```js showLineNumbers copy
const person1 = {
  age: 10
};
const person2 = person1;

person1.age = 20;

console.log(person2);
```

<br/>

<Collapse>
  <Collapse.Panel header="콘솔에 출력되는 결과는 무엇일까요? 기존에 설명드린 포스트잇에 대입하여 3분 이상 생각해보시고 설명을 열어서 읽어보세요.">
    <p>
      기존 규칙을 다시 상기시켜 보세요.

      * 하나의 포스트잇에는 하나의 정보만 적을 수 있고, 재활용하지 않습니다.
      * 참조값 형태의 자료들은 그 부피가 방대하여 포스트잇에 적을 수 없습니다.
      * 참조값 형태의 실제 자료들은 별도의 자료 저장소인 서랍장에 보관해야 하며, 하나의 서랍장에는 하나의 자료만 보관할 수 있습니다.
      * 참조값(객체)을 담는 포스트잇에는 그 자료의 **서랍장 위치**를 적어 놓습니다.

      ```js showLineNumbers copy
      const person1 = {
        age: 10
      };
      const person2 = person1;

      person1.age = 20;

      console.log(person2);
      ```

      기존 규칙을 명심하고, 위 예시 코드의 흐름을 따라가 보겠습니다.

      1. 1번째 줄의 코드는 **객체를 생성하는 코드**입니다.
      2. 1번째 줄의 `{ age: 10 }` 객체는 참조형 자료이므로 포스트잇에 적을 수 없습니다. 그러므로 별도의 저장 공간인 **서랍장 첫 번째 칸**에 보관합니다.
      3. 1번째 줄의 `person1`이라는 이름의 포스트잇에는 **서랍장 첫 번째 칸**이라고 해당 자료가 보관된 위치 정보를 적습니다.
      4. 4번째 줄의 코드는 **`person1`의 값을 `person2`에게 대입하는 코드**입니다.
      5. 4번째 줄의 코드는 `person2`라는 포스트잇을 만들고, `person1` 포스트잇에 적힌 정보를 똑같이 적어놓습니다.
      6. 즉, 4번째 줄의 코드에서 `person2` 포스트잇에는 **서랍장 첫 번째 칸**이라는 정보가 적히게 됩니다.
      7. 6번째 줄의 `person1.age = 20;{:js}`구문에서 우리는 `person1`을 사용하고 있습니다.
      8. 6번째 줄의 코드에 의해, 자바스크립트는 우선 `person1` 포스트잇에 적힌 정보를 조회합니다. 그 결과 **서랍장 첫 번째 칸**이라는 정보를 찾습니다. 조회 결과에 따라 자바스크립트는 `person1`이 객체라는 사실을 알게 되고, **서랍장 첫 번째 칸**에 위치한 객체의 `age`라는 속성에 대한 값을 20으로 부여(혹은 덮어쓰기)합니다.
      9. 8번째 줄에서 우리는 `person2`라는 포스트잇의 값을 출력하려 합니다. 그렇기에 자바스크립트는 해당 포스트잇의 값이 무엇인지 조회합니다.
      10. 8번째 줄의 `person2`라는 포스트잇에는 6번 단계에서 **서랍장 첫 번째 칸**이라는 정보를 적어두었습니다. 그렇기에, 서랍장 첫 번째 칸에 위치한 자료를 꺼내와 콘솔에 출력하게 됩니다.
      11. 8번째 줄에서 출력하는 **서랍장 첫 번째 칸**에 위치한 자료는 8번 단계에서 `age`라는 속성에 대한 값이 20으로 변경된 이력이 있기에, 결과적으로 `{ age: 20 }{:js}`와 같이 생긴 객체가 출력됩니다.

      조금 이해에 도움이 되었을까요?
    </p>
  </Collapse.Panel>
</Collapse>

<br />
<br />

머리가 복잡하시죠? 하지만 아직 더욱 재밌는 예시가 남아있습니다. 조금만 더 집중해보세요!

##### 예시 5.

```js showLineNumbers copy
const ken = {
  work: "vaco",
  position: "instructor"
};
const wan = {
  work: "google",
  position: "data scientist"
};
const myFamily = {
  children: [
    ken,
    wan
  ]
};

function changeJob (person) {
  person.work = "home";
  person.position = "dad";
}

changeJob(wan);

console.log(myFamily);
```

<br/>

<Collapse>
  <Collapse.Panel header="콘솔에 출력되는 결과에서 `wan`의 내용은 어떻게 생겼을까요? 기존에 설명드린 포스트잇에 대입하여 양심에 손을 얹고 최소 3분 이상 생각해보시고 설명을 열어서 읽어보세요.">
    <p>
      기존 규칙을 명심하고, 위 예시 코드의 흐름을 따라가 보겠습니다.

      1. 1번째 줄에서 `ken`이라는 포스트잇을 만들고, 객체를 **서랍장 1번째 칸**에 보관한 후, 그 위치를 포스트잇에 적어 놓습니다.
      2. 5번째 줄에서 `wan`이라는 포스트잇을 만들고, 객체를 **서랍장 2번째 칸**에 보관한 후, 그 위치를 포스트잇에 적어 놓습니다.
      3. 9번째 줄에서 `myFamily`이라는 포스트잇을 만들고, 객체를 **서랍장 3번째 칸**에 보관한 후, 그 위치를 포스트잇에 적어 놓습니다.
      4. 9번째 줄에서 만든 객체는, `children`이라는 속성을 갖고 있고 속성 또한 일종의 포스트잇과 동일합니다.
      5. `children`이라는 포스트잇에는 배열을 생성하여 담고 있습니다. 그러므로 배열을 **서랍장 4번째 칸**에 보관한 후, 그 위치를 `children` 포스트잇에 적어 놓습니다.
      6. `children` 포스트잇이 가리키는 배열은 `ken`과 `wan`이라는 2개의 요소를 담고 있습니다. 이 요소들은 포스트잇임을 명심하세요.
      7. 16번째 줄에서 `changeJob`이라는 포스트잇이 만들어지고, 함수를 만들어 **서랍장 5번째 칸**에 보관한 후, 그 위치를 포스트잇에 적어 놓습니다.
      8. 21번째 줄에서 `changeJob`이라는 포스트잇을 찾아, `wan`이라는 인자를 넣어 실행시킵니다.
      9. 16번째 줄의 `changeJob` 함수 내용이 실행되고, `person`이라는 포스트잇(매개변수)에 `wan`이라는 포스트잇의 내용(**서랍장 2번째 칸**)이 담겨집니다.
      10. 17, 18번째 줄의 코드는 결과적으로 **서랍장 2번째 칸**에 담긴 객체의 속성과 값을 수정하고, `changeJob` 함수의 내용이 종료됩니다.
      11. 23번째 줄의 콘솔 출력문이 실행되며, `myFamily` 포스트잇의 내용을 조회합니다.
      12. `myFamily` 객체는 `children` 포스트잇과 연결되어 있고, `children` 포스트잇의 자료는 `ken`과 `wan` 포스트잇을 가리키고 있습니다.
      13. `myFamily` 객체의 내용을 `{ children: [ 서랍장 1번째 칸, 서랍장 2번째 칸 ] }{:js}`이라고 볼 수 있으므로, 콘솔에 출력되는 내용에서 `wan`의 데이터는 `"home"`과 `"dad"`로 변경되었음을 확인할 수 있습니다.

      실제로 제 동생은 현재 육아 휴직 중인 상황입니다. 조금 이해에 도움이 되었을까요?
    </p>
  </Collapse.Panel>
</Collapse>

<br/>
<br/>
<br/>
<Giscus
  repo="crwdu/lms-contents-js101"
  repoId="R_kgDOL2ikqQ"
  category="Q&A"
  categoryId="DIC_kwDOL2ikqc4CgSAu"
  mapping="pathname"
  reactionsEnabled="1"
  strict="1"
  emitMetadata="0"
  inputPosition="top"
  theme="preferred_color_scheme"
  lang="ko"
  loading="lazy"
/>